import * as Path from 'path';
import * as FS from 'fs-extra';
import * as ts from 'typescript';

export interface LibraryBuildMeta {
  /**
   * The source directory, where `package.json` is.
   *
   * > Relative to the location of the configuration file
   *
   * If not set, the source directory is assumed to be at the same location of the configuration file (i.e. ".")
   * @default .
   */
  src?: string;

  /**
   * The destination directory, where all output files are saved.
   * This is equivalent to "outDir" in tsconfig.
   * If "outDir" is set in `compilerOptions` it is ignored.
   *
   *
   * > Relative to the location of the configuration file
   *
   * If not set, the destination directory is set to "dist"
   * @default dist
   */
  dest?: string;

  /**
   * The main entry point.
   *
   * > Relative to the location of the configuration file
   *
   * If not set, the  main entry point is set to 'index.ts'
   * @default index.ts
   */
  entry?: string;

  /**
   * An optional list of additional declaration files (d.ts) to include in the compilation.
   *
   * > Relative to the location of the configuration file
   *
   * @default []
   */
  dtsFiles?: string[];

  /**
   * The name of the new entry point generated by the AOT compiler.
   *
   * e.g.: myFlatFile.js
   *
   * If not set, the name of the library is used.
   *
   * > If the name does not end with .js a .js will be added.
   */
  flatModuleFileName?: string;

  /**
   * The name of the library.
   * If not set, the name is taken from the `package.json` name property. (scope excluded, last node taken)
   */
  name?: string;

  /**
   * Preferred module id to use for importing flat module.
   *
   * If not set, the name from package.json is used (as is, with scopes and deep paths)
   */
  moduleId?: string;

  /**
   * Compiler options for the typescript compiler, these values will overwrite existing values.
   *
   * Note that the values specified here must be relative to the current file they are in and NOT relative to the
   * location of the tsconfig file.
   * `ngc-webpack` will map all properties referencing file paths to be relative to the location of the tsconfig file.
   *
   * All other file referencing properties that are imported from the tsconfig are left as is.
   *
   * The rule is simple: A relative path is always relative to the file it is defined on.
   *
   * > Some properties in `tsconfig` are set by `ngc-webpack`: `compilerOptions.outDir`, `files` & `include` (removed)
   * @default {}
   */
  compilerOptions?: ts.CompilerOptions;

  /**
   * When true, this configuration extends the first item in the configuration list.
   * Valid only for a multi-configuration setup (array, not single object) and only for items at index > 0
   *
   * This means that in a multi-configuration setup the only extendable configuration is the first item.
   */
  extendsFirst?: boolean;
}

function relativePathMapperFactory(newRoot: string, oldRoot: string): (relPath: string) => string {
  return (relPath: string) => Path.relative(newRoot, Path.resolve(oldRoot, relPath));
}

export class BuildConfig {
  src: string;
  dest: string;
  entry: string;
  dtsFiles: string[];
  flatModuleFileName: string;
  name: string;
  moduleId: string;
  compilerOptions: ts.CompilerOptions;

  metaDir: string;
  pkgJson: any;
  scope: string;
  /**
   * Name as taken from package.json
   */
  rawName: string;

  tsConfig: any;

  updateTsConfig(tsConfigDir: string, tsConfig: any): void {
    const mapper = relativePathMapperFactory(tsConfigDir, this.metaDir);

    Object.assign(tsConfig.compilerOptions, this.compilerOptions);

    ['baseUrl', 'declarationDir', 'rootDir']
      .forEach(k => {
        if (tsConfig.compilerOptions.hasOwnProperty(k)) {
          tsConfig.compilerOptions[k] = mapper(<any> tsConfig.compilerOptions[k]);
        }
      });
    if (tsConfig.compilerOptions.rootDirs) {
      tsConfig.compilerOptions.rootDirs = tsConfig.compilerOptions.rootDirs.map(f => mapper(f));
    }

    delete tsConfig.include;
    tsConfig.files = [ mapper(this.entry), ...this.dtsFiles.map( f => mapper(f) )];
    tsConfig.compilerOptions.outDir = mapper(this.dest);

    tsConfig.angularCompilerOptions = {
        annotateForClosureCompiler: true,
        skipMetadataEmit: false,
        skipTemplateCodegen: true,
        strictMetadataEmit: true,
        flatModuleOutFile: this.flatModuleFileName,
        flatModuleId: this.moduleId
    };

    this.tsConfig = tsConfig;
  }

  static create(rawPath: string, raw: LibraryBuildMeta, buildConfig?: BuildConfig): BuildConfig  {
    if (!buildConfig) {
      buildConfig = new BuildConfig();
    }

    buildConfig.metaDir = rawPath;
    buildConfig.src = raw.src || '.';

    if (!buildConfig.pkgJson) {
      const pkgJsonPath = Path.resolve(rawPath, buildConfig.src, 'package.json');
      if (!FS.existsSync(pkgJsonPath)) {
        throw new Error(`could not find "package.json" in ${pkgJsonPath}`);
      }

      buildConfig.pkgJson = FS.readJSONSync(pkgJsonPath);
    }

    const pkgJson = buildConfig.pkgJson;
    buildConfig.rawName = pkgJson.name;
    const nameParts = pkgJson.name.split('/');
    if (nameParts.length > 1 && nameParts[0] === '@') {
      buildConfig.scope = nameParts[0];
      buildConfig.name = nameParts[1];
    } else {
      buildConfig.scope = '';
      buildConfig.name = nameParts[0];
    }

    if (raw.name) {
      buildConfig.name = raw.name;
    }

    buildConfig.moduleId = raw.moduleId || buildConfig.rawName;

    buildConfig.dest = raw.dest || 'dist';
    buildConfig.entry = raw.entry || 'index.ts';
    buildConfig.dtsFiles = raw.dtsFiles || [];

    buildConfig.flatModuleFileName = raw.flatModuleFileName || buildConfig.name;
    if (! /.+\.js/.test(buildConfig.flatModuleFileName)) {
      buildConfig.flatModuleFileName = buildConfig.flatModuleFileName + '.js';
    }

    buildConfig.compilerOptions = raw.compilerOptions || {};


    return buildConfig;
  }
}